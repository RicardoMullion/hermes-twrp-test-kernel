From f968d6ded7bdb1264dd1e7419d937ff6cec79a48 Mon Sep 17 00:00:00 2001
From: WisniaPL <19wisnia89@gmail.com>
Date: Wed, 8 Feb 2017 03:41:10 +0100
Subject: [PATCH]  mt67xx: Add an RGB configuration sys attr driver for
 videox/corr10

Adds the RGB configuration node which leverages the gamma subsystem to
perform color correction.

The new node takes rgb triplets that range from 0-2000 each, computes
the gamma registers and dispatches them to the gamma correction
subsystem.

Change-Id: Iac9d3cbd4f423ccfffb8d665c29cfd251767a398
---
 arch/arm64/configs/infernus_defconfig              |  1 +
 drivers/misc/mediatek/video/Kconfig                |  6 ++
 .../misc/mediatek/video/common/corr10/ddp_gamma.c  |  9 ++-
 .../mediatek/video/mt6795/videox/mtk_disp_mgr.c    | 85 ++++++++++++++++++++++
 4 files changed, 99 insertions(+), 2 deletions(-)
 
diff --git a/drivers/misc/mediatek/video/Kconfig b/drivers/misc/mediatek/video/Kconfig
index 08960d4..8ef51fc 100644
--- a/drivers/misc/mediatek/video/Kconfig
+++ b/drivers/misc/mediatek/video/Kconfig
@@ -3,3 +3,9 @@ config MTK_VIDEO
   default n
   help
     CONFIG_MTK_VIDEO
+
+config MTK_VIDEOX_CYNGN_LIVEDISPLAY
+	bool CONFIG_MTK_VIDEOX_CYNGN_LIVEDISPLAY
+	default n
+	help
+		Enable the RGB interface for color calibration.
diff --git a/drivers/misc/mediatek/video/common/corr10/ddp_gamma.c b/drivers/misc/mediatek/video/common/corr10/ddp_gamma.c
index 2c9deff..dc51fd5 100644
--- a/drivers/misc/mediatek/video/common/corr10/ddp_gamma.c
+++ b/drivers/misc/mediatek/video/common/corr10/ddp_gamma.c
@@ -144,11 +144,16 @@ static int disp_gamma_set_lut(const DISP_GAMMA_LUT_T __user *user_gamma_lut, voi
 		GAMMA_ERR("disp_gamma_set_lut: no memory\n");
 		return -EFAULT;
 	}
-
+#ifdef CONFIG_MTK_VIDEOX_CYNGN_LIVEDISPLAY
+	if (virt_addr_valid(user_gamma_lut)) {
+		memcpy(gamma_lut, user_gamma_lut, sizeof(DISP_GAMMA_LUT_T));
+	} else
+#endif
 	if (copy_from_user(gamma_lut, user_gamma_lut, sizeof(DISP_GAMMA_LUT_T)) != 0) {
 		ret = -EFAULT;
 		kfree(gamma_lut);
-	} else {
+	}
+	if (!ret) {
 		id = gamma_lut->hw_id;
 		if (0 <= id && id < DISP_GAMMA_TOTAL) {
 			mutex_lock(&g_gamma_global_lock);
diff --git a/drivers/misc/mediatek/video/mt6795/videox/mtk_disp_mgr.c b/drivers/misc/mediatek/video/mt6795/videox/mtk_disp_mgr.c
index da4b770..3354c97 100644
--- a/drivers/misc/mediatek/video/mt6795/videox/mtk_disp_mgr.c
+++ b/drivers/misc/mediatek/video/mt6795/videox/mtk_disp_mgr.c
@@ -133,6 +133,13 @@ static int mtk_disp_mgr_mmap(struct file *file, struct vm_area_struct *vma)
 
 #define DDP_OUTPUT_LAYID 4
 
+#ifdef CONFIG_MTK_VIDEOX_CYNGN_LIVEDISPLAY
+static struct mtk_rgb_work_queue {
+        struct work_struct work;
+	struct mutex lock;
+} mtk_rgb_work_queue;
+#endif
+
 static unsigned int session_config[MAX_SESSION_COUNT];
 static DEFINE_MUTEX(disp_session_lock);
 
@@ -1970,9 +1977,83 @@ static struct platform_device mtk_disp_mgr_device = {
 	},
 	.num_resources = 0,
 };
+#ifdef CONFIG_MTK_VIDEOX_CYNGN_LIVEDISPLAY
+#define MAX_LUT_SCALE 2000
+#define PROGRESSION_SCALE 1000
+static u32 mtk_disp_ld_r = MAX_LUT_SCALE;
+static u32 mtk_disp_ld_g = MAX_LUT_SCALE;
+static u32 mtk_disp_ld_b = MAX_LUT_SCALE;
+
+static ssize_t mtk_disp_ld_get_rgb(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE, "%d %d %d\n", mtk_disp_ld_r, mtk_disp_ld_g, mtk_disp_ld_b);
+}
+
+/**
+ * The default gamma array is an arithmetic progression with alpha=2 and n0=0 and
+ * n = 512.
+ *
+ * We scale it linearly with the color passed to this RGB interface. The display
+ * subsystem has a color precision of 10 bits which means that values from [0-1024[
+ * are acceptable.
+ *
+ * In order to avoid floating point computations in kernel space we scale the alpha
+ * value by 1000 and then scale back the result using integer division.
+ */
+static ssize_t mtk_disp_ld_set_rgb(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int r = MAX_LUT_SCALE, g = MAX_LUT_SCALE, b = MAX_LUT_SCALE;
+
+	if (count > 19)
+		return -EINVAL;
+
+	sscanf(buf, "%d %d %d", &r, &g, &b);
+
+	if (r < 0 || r > MAX_LUT_SCALE) return -EINVAL;
+	if (g < 0 || g > MAX_LUT_SCALE) return -EINVAL;
+	if (b < 0 || b > MAX_LUT_SCALE) return -EINVAL;
+
+	cancel_work_sync(&mtk_rgb_work_queue.work);
+	mtk_disp_ld_r = r;
+	mtk_disp_ld_g = g;
+	mtk_disp_ld_b = b;
+	schedule_work(&mtk_rgb_work_queue.work);
+
+	return count;
+}
+
+static DEVICE_ATTR(rgb, S_IRUGO | S_IWUSR | S_IWGRP, mtk_disp_ld_get_rgb, mtk_disp_ld_set_rgb);
+
+static void mtk_disp_rgb_work(struct work_struct *work) {
+        struct mtk_rgb_work_queue *rgb_wq = container_of(work, struct mtk_rgb_work_queue, work);
+	int r = mtk_disp_ld_r, g = mtk_disp_ld_g, b = mtk_disp_ld_b;
+	int i, gammutR, gammutG, gammutB, ret;
+	DISP_GAMMA_LUT_T *gamma;
+
+	mutex_lock(&rgb_wq->lock);
+
+	gamma = kzalloc(sizeof(DISP_GAMMA_LUT_T), GFP_KERNEL);
+	gamma->hw_id = 0;
+	for (i = 0; i < 512; i++) {
+		gammutR = i * r / PROGRESSION_SCALE;
+		gammutG = i * g / PROGRESSION_SCALE;
+		gammutB = i * b / PROGRESSION_SCALE;
+
+		gamma->lut[i] = GAMMA_ENTRY(gammutR, gammutG, gammutB);
+	}
+
+	ret = primary_display_user_cmd(DISP_IOCTL_SET_GAMMALUT, (unsigned long)gamma);
+
+	kfree(gamma);
+	mutex_unlock(&rgb_wq->lock);
+}
+#endif
 
 static int __init mtk_disp_mgr_init(void)
 {
+ 	int rc = 0; 
 	if (platform_device_register(&mtk_disp_mgr_device))
 		return -ENODEV;
 
@@ -1988,6 +2069,10 @@ static int __init mtk_disp_mgr_init(void)
 
 static void __exit mtk_disp_mgr_exit(void)
 {
+#ifdef CONFIG_MTK_VIDEOX_CYNGN_LIVEDISPLAY
+	mutex_destroy(&mtk_rgb_work_queue.lock);
+	sysfs_remove_file(&(mtk_disp_mgr_device.dev.kobj), &dev_attr_rgb.attr);
+#endif
 	cdev_del(mtk_disp_mgr_cdev);
 	unregister_chrdev_region(mtk_disp_mgr_devno, 1);
 

